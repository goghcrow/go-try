## ğ–ğ¡ğšğ­ ğ¢ğ¬ ğ•˜ğ• -ğ•¥ğ•£ğ•ª

A source to source translator for error-propagating in golang.

The implementation of [***Proposal: A built-in Go error check function, try***](https://github.com/golang/proposal/blob/master/design/32437-try-builtin.md).


## Quick Start

Create source files ending with `_try.go` / `_try_test.go`.

Build tag `//go:build try` required.

Then `go generate -tags try ./...` (or run by IDE whatever).

And it is a good idea to switch custom build tag to `try` when working in goland or vscode,
so IDE will be happy to index and check your code.

## Example

Create file `copyfile_try.go`.

```golang
//go:build try

//go:generate go install github.com/goghcrow/go-try/cmd/trygen@main
//go:generate trygen

package example

import (
	"fmt"
	"io"
	"os"

	. "github.com/goghcrow/go-try"
)

// CopyFile example
// from https://github.com/golang/proposal/blob/master/design/32437-try-builtin.md#examples
//
//goland:noinspection GoUnhandledErrorResult
func CopyFile(src, dst string) (err error) {
	defer HandleErrorf(&err, "copy %s %s", src, dst)

	r := Try(os.Open(src))
	defer r.Close()

	w := Try(os.Create(dst))
	defer func() {
		w.Close()
		if err != nil {
			os.Remove(dst) // only if a â€œtryâ€ fails
		}
	}()

	Try(io.Copy(w, r))
	Try0(w.Close())
	return nil
}

func HandleErrorf(err *error, format string, args ...any) {
	if *err != nil {
		*err = fmt.Errorf(format+": %v", append(args, *err)...)
	}
}
```

run go:generate and output `copyfile.go`.

```golang
//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package example

import (
	"fmt"
	"io"
	"os"
)

func CopyFile(src, dst string) (err error) {
	defer HandleErrorf(&err, "copy %s %s", src, dst)
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := os.Open(src)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	r := ğ˜ƒğ—®ğ—¹ğŸ­
	defer r.Close()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := os.Create(dst)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ®
		return
	}
	w := ğ˜ƒğ—®ğ—¹ğŸ®
	defer func() {
		w.Close()
		if err != nil {
			os.Remove(dst)
		}
	}()
	_, ğ—²ğ—¿ğ—¿ğŸ¯ := io.Copy(w, r)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}

	ğ—²ğ—¿ğ—¿ğŸ° := w.Close()
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ°
		return
	}

	return nil
}
func HandleErrorf(err *error, format string, args ...any) {
	if *err != nil {
		*err = fmt.Errorf(format+": %v", append(args, *err)...)
	}
}
```

## Translating Examples

### prelude

```golang
package test

func func1[A, R any](a A) (_ R, _ error) { return }

func return1[A any]() (_ A)                          { return }
func ret0Err() (_ error)                             { return }
func ret1Err[A any]() (_ A, _ error)                 { return }
func ret2Err[A, B any]() (_ A, _ B, _ error)         { return }
func ret3Err[A, B, C any]() (_ A, _ B, _ C, _ error) { return }

func consume1[A any](A)             {}
func consume2[A, B any](A, B)       {}
func consume3[A, B, C any](A, B, C) {}

func id[A any](a A) A { return a }

func handleErrorf(err *error, format string, args ...interface{}) {
	if *err != nil {
		*err = fmt.Errorf(format+": %v", append(args, *err)...)
	}
}
```

### Error Handling

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
func error_wrapping() (a int, err error) {
	defer handleErrorf(&err, "something wrong")
	Try(ret1Err[bool]())
	a = 42
	return
}
```

</td>
<td>

```golang
func error_wrapping() (a int, err error) {
    defer handleErrorf(&err, "something wrong")
    _, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[bool]()
    if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
        err = ğ—²ğ—¿ğ—¿ğŸ­
        return
    }
    a = 42
    return
}
```

</td>
</tr>

</table>

### Order of Evaluation

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
type (
	A = int
	B = int
	C = int
)
println(
	[]func(int) int{}[id[int](0)+Try(ret1Err[A]())](
		id[int](1)+Try(ret1Err[B]()),
	) + Try(ret1Err[C]()) + id[int](2),
)
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­ := id[int](0)
ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[A]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ­
}
ğ˜ƒğ—®ğ—¹ğŸ¯ := []func(int) int{}[ğ˜ƒğ—®ğ—¹ğŸ­+ğ˜ƒğ—®ğ—¹ğŸ®]
ğ˜ƒğ—®ğ—¹ğŸ° := id[int](1)
ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[B]()
if ğ—²ğ—¿ğ—¿ğŸ® != nil {
	return ğ—²ğ—¿ğ—¿ğŸ®
}
ğ˜ƒğ—®ğ—¹ğŸ² := ğ˜ƒğ—®ğ—¹ğŸ¯(ğ˜ƒğ—®ğ—¹ğŸ° + ğ˜ƒğ—®ğ—¹ğŸ±)
ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ¯ := ret1Err[C]()
if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ¯
}
ğ˜ƒğ—®ğ—¹ğŸ´ := id[int](2)
println(ğ˜ƒğ—®ğ—¹ğŸ² + ğ˜ƒğ—®ğ—¹ğŸ³ + ğ˜ƒğ—®ğ—¹ğŸ´)
```

</td>
</tr>

</table>

### Logical Operator Or

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
_ = id(true) || Try(func1[int, bool](2)) || id(false)
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­ := id(true)
if !ğ˜ƒğ—®ğ—¹ğŸ­ {
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := func1[int, bool](2)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	ğ˜ƒğ—®ğ—¹ğŸ­ = ğ˜ƒğ—®ğ—¹ğŸ®
}
if !ğ˜ƒğ—®ğ—¹ğŸ­ {
	ğ˜ƒğ—®ğ—¹ğŸ­ = id(false)
}
_ = ğ˜ƒğ—®ğ—¹ğŸ­
```

</td>
</tr>

</table>

### Logical Operator And

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
_ = id(true) && Try(func1[int, bool](2)) && id(false)
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­ := id(true)
if ğ˜ƒğ—®ğ—¹ğŸ­ {
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := func1[int, bool](2)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	ğ˜ƒğ—®ğ—¹ğŸ­ = ğ˜ƒğ—®ğ—¹ğŸ®
}
if ğ˜ƒğ—®ğ—¹ğŸ­ {
	ğ˜ƒğ—®ğ—¹ğŸ­ = id(false)
}
_ = ğ˜ƒğ—®ğ—¹ğŸ­
```

</td>
</tr>

</table>

### If Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
if Try(func1[int, bool](1)) {
} else if false {
} else if a := Try(func1[int, bool](2)); a {
} else if Try(func1[int, bool](3)) {
} else if true {
}
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := func1[int, bool](1)
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ­
}
if ğ˜ƒğ—®ğ—¹ğŸ­ {
} else if false {
} else {
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := func1[int, bool](2)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	if a := ğ˜ƒğ—®ğ—¹ğŸ®; a {
	} else {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := func1[int, bool](3)
		if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ¯
		}
		if ğ˜ƒğ—®ğ—¹ğŸ¯ {
		} else if true {
		}
	}
}
```

</td>
</tr>

</table>

### For Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
for i := Try(ret1Err[A]()); 
    Try(func1[int, bool](i)); Try(func1[A, C](i)) {
    println(i)
}
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[A]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ­
}
for i := ğ˜ƒğ—®ğ—¹ğŸ­; ; {
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := func1[int, bool](i)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	if !ğ˜ƒğ—®ğ—¹ğŸ® {
		break
	}
	println(i)
	_, ğ—²ğ—¿ğ—¿ğŸ¯ := func1[A, C](i)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ¯
	}
}
```

</td>
</tr>

</table>

### Range Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
Outer:
	for range Try(ret1Err[[]int]()) {
	Inner:
		for range Try(ret1Err[[]string]()) {
			switch a {
			case 1:
				goto Inner
			case 2:
				goto Outer
			case 3:
				break Inner
			case 4:
				break Outer
			case 5:
				continue Inner
			case 6:
				continue Outer
			}
		}
	}
```

</td>
<td>

```golang
ğ—Ÿ_ğ—šğ—¼ğ˜ğ—¼_ğ—¢ğ˜‚ğ˜ğ—²ğ—¿ğŸ­:
	{
		ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[[]int]()
		if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ­
		}
	Outer:
		for range ğ˜ƒğ—®ğ—¹ğŸ­ {
		ğ—Ÿ_ğ—šğ—¼ğ˜ğ—¼_ğ—œğ—»ğ—»ğ—²ğ—¿ğŸ­:
			{
				ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[[]string]()
				if ğ—²ğ—¿ğ—¿ğŸ® != nil {
					return ğ—²ğ—¿ğ—¿ğŸ®
				}
			Inner:
				for range ğ˜ƒğ—®ğ—¹ğŸ® {
					switch a {
					case 1:
						goto ğ—Ÿ_ğ—šğ—¼ğ˜ğ—¼_ğ—œğ—»ğ—»ğ—²ğ—¿ğŸ­
					case 2:
						goto ğ—Ÿ_ğ—šğ—¼ğ˜ğ—¼_ğ—¢ğ˜‚ğ˜ğ—²ğ—¿ğŸ­
					case 3:
						break Inner
					case 4:
						break Outer
					case 5:
						continue Inner
					case 6:
						continue Outer
					}
				}
			}
		}
	}
```

</td>
</tr>

</table>

### Switch Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
switch i := Try(func1[int, A](0)); Try(func1[int, A](i)) {
    case Try(func1[int, B](i)):
        println("B")
    case id[int](i):
        println("C")
    case Try(func1[int, D](i)):
        println("D1")
    case id[int](i):
        println("E")
    case Try(func1[int, D](i)):
        println("D2")
    default:
        println("default")
}
```

</td>
<td>

```golang
{
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := func1[int, A](0)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	i := ğ˜ƒğ—®ğ—¹ğŸ®
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := func1[int, A](i)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	ğ˜ƒğ—®ğ—¹ğŸ­ := ğ˜ƒğ—®ğ—¹ğŸ¯
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := func1[int, B](i)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ¯
	}
	if ğ˜ƒğ—®ğ—¹ğŸ­ == ğ˜ƒğ—®ğ—¹ğŸ° {
		println("B")
	} else if ğ˜ƒğ—®ğ—¹ğŸ­ == id[int](i) {
		println("C")
	} else {
		ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ° := func1[int, D](i)
		if ğ—²ğ—¿ğ—¿ğŸ° != nil {
			return ğ—²ğ—¿ğ—¿ğŸ°
		}
		if ğ˜ƒğ—®ğ—¹ğŸ­ == ğ˜ƒğ—®ğ—¹ğŸ± {
			println("D1")
		} else if ğ˜ƒğ—®ğ—¹ğŸ­ == id[int](i) {
			println("E")
		} else {
			ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ± := func1[int, D](i)
			if ğ—²ğ—¿ğ—¿ğŸ± != nil {
				return ğ—²ğ—¿ğ—¿ğŸ±
			}
			if ğ˜ƒğ—®ğ—¹ğŸ­ == ğ˜ƒğ—®ğ—¹ğŸ² {
				println("D2")
			} else {
				println("default")
			}
		}
	}
}
```

</td>
</tr>

</table>

### Switch Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
outer:
	switch {
	case Try(func1[int, A](1)) == 42:
		println("outer")
	inner:
		switch {
		case Try(func1[int, B](1)) == 42:
			break inner
		case Try(func1[int, C](1)) == 42:
			goto inner
		case Try(func1[int, D](1)) == 42:
			println("inner")
			break outer
		case Try(func1[int, E](1)) == 42:
			println("inner")
			goto outer
		}
	default:
		println("default")
	}
```

</td>
<td>

```golang
outer:
	{
		ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := func1[int, A](1)
		if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ­
		}
		if ğ˜ƒğ—®ğ—¹ğŸ­ == 42 {
			println("outer")
		inner:
			{
				ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := func1[int, B](1)
				if ğ—²ğ—¿ğ—¿ğŸ® != nil {
					return ğ—²ğ—¿ğ—¿ğŸ®
				}
				if ğ˜ƒğ—®ğ—¹ğŸ® == 42 {
					goto ğ—Ÿ_ğ—•ğ—¿ğ—¸ğ—§ğ—¼_ğ—¶ğ—»ğ—»ğ—²ğ—¿ğŸ­
				} else {
					ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := func1[int, C](1)
					if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
						return ğ—²ğ—¿ğ—¿ğŸ¯
					}
					if ğ˜ƒğ—®ğ—¹ğŸ¯ == 42 {
						goto inner
					} else {
						ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ° := func1[int, D](1)
						if ğ—²ğ—¿ğ—¿ğŸ° != nil {
							return ğ—²ğ—¿ğ—¿ğŸ°
						}
						if ğ˜ƒğ—®ğ—¹ğŸ° == 42 {
							println("inner")
							goto ğ—Ÿ_ğ—•ğ—¿ğ—¸ğ—§ğ—¼_ğ—¼ğ˜‚ğ˜ğ—²ğ—¿ğŸ­
						} else {
							ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ± := func1[int, E](1)
							if ğ—²ğ—¿ğ—¿ğŸ± != nil {
								return ğ—²ğ—¿ğ—¿ğŸ±
							}
							if ğ˜ƒğ—®ğ—¹ğŸ± == 42 {
								println("inner")
								goto outer
							}
						}
					}
				}
			ğ—Ÿ_ğ—•ğ—¿ğ—¸ğ—§ğ—¼_ğ—¶ğ—»ğ—»ğ—²ğ—¿ğŸ­:
			}
		} else {
			println("default")
		}
	ğ—Ÿ_ğ—•ğ—¿ğ—¸ğ—§ğ—¼_ğ—¼ğ˜‚ğ˜ğ—²ğ—¿ğŸ­:
	}
```

</td>
</tr>

</table>

### Switch Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
type (
	A = int
	B = int
	C = int
	D = int
	E = int
	F = int
)
switch i {
case Try(ret1Err[A]()):
	Try(ret1Err[B]())
	fallthrough
case Try(ret1Err[C]()):
	Try(ret1Err[D]())
	fallthrough
case Try(ret1Err[E]()):
	Try(ret1Err[F]())
}
```

</td>
<td>

```golang
type (
	A = int
	B = int
	C = int
	D = int
	E = int
	F = int
)
{
	ğ˜ƒğ—®ğ—¹ğŸ­ := i
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[A]()
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	if ğ˜ƒğ—®ğ—¹ğŸ­ == ğ˜ƒğ—®ğ—¹ğŸ® {
		{
			_, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[B]()
			if ğ—²ğ—¿ğ—¿ğŸ® != nil {
				err = ğ—²ğ—¿ğ—¿ğŸ®
				return
			}

		}
		{
			_, ğ—²ğ—¿ğ—¿ğŸ¯ := ret1Err[D]()
			if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
				err = ğ—²ğ—¿ğ—¿ğŸ¯
				return
			}

		}
		{
			_, ğ—²ğ—¿ğ—¿ğŸ° := ret1Err[F]()
			if ğ—²ğ—¿ğ—¿ğŸ° != nil {
				err = ğ—²ğ—¿ğ—¿ğŸ°
				return
			}

		}
	} else {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ± := ret1Err[C]()
		if ğ—²ğ—¿ğ—¿ğŸ± != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ±
			return
		}
		if ğ˜ƒğ—®ğ—¹ğŸ­ == ğ˜ƒğ—®ğ—¹ğŸ¯ {
			{
				_, ğ—²ğ—¿ğ—¿ğŸ² := ret1Err[D]()
				if ğ—²ğ—¿ğ—¿ğŸ² != nil {
					err = ğ—²ğ—¿ğ—¿ğŸ²
					return
				}

			}
			{
				_, ğ—²ğ—¿ğ—¿ğŸ³ := ret1Err[F]()
				if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
					err = ğ—²ğ—¿ğ—¿ğŸ³
					return
				}

			}
		} else {
			ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ´ := ret1Err[E]()
			if ğ—²ğ—¿ğ—¿ğŸ´ != nil {
				err = ğ—²ğ—¿ğ—¿ğŸ´
				return
			}
			if ğ˜ƒğ—®ğ—¹ğŸ­ == ğ˜ƒğ—®ğ—¹ğŸ° {
				_, ğ—²ğ—¿ğ—¿ğŸµ := ret1Err[F]()
				if ğ—²ğ—¿ğ—¿ğŸµ != nil {
					err = ğ—²ğ—¿ğ—¿ğŸµ
					return
				}

			}
		}
	}
}
```

</td>
</tr>

</table>

### Select Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
type (
	A = int
	B = int
	C = int
	D = int
	E = int
	F = int
	G = int
	H = int
)
select {
    case <-Try(ret1Err[chan A]()):
    case *Try(ret1Err[*B]()), *Try(ret1Err[*bool]()) = 
        <-Try(ret1Err[chan C]()):
    case Try(ret1Err[chan D]()) 
        <- Try(ret1Err[E]()):
    case Try(ret1Err[[]F]())[Try(ret1Err[G]())] = 
        <-Try(ret1Err[chan H]()):
    default:
}
```

</td>
<td>

```golang
type (
	A = int
	B = int
	C = int
	D = int
	E = int
	F = int
	G = int
	H = int
)
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[chan A]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ­
}
ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[chan C]()
if ğ—²ğ—¿ğ—¿ğŸ® != nil {
	return ğ—²ğ—¿ğ—¿ğŸ®
}
ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ± := ret1Err[chan D]()
if ğ—²ğ—¿ğ—¿ğŸ± != nil {
	return ğ—²ğ—¿ğ—¿ğŸ±
}
ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ² := ret1Err[E]()
if ğ—²ğ—¿ğ—¿ğŸ² != nil {
	return ğ—²ğ—¿ğ—¿ğŸ²
}
ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ³ := ret1Err[chan H]()
if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ³
}
select {
    case <-ğ˜ƒğ—®ğ—¹ğŸ­:
    case ğ˜ƒğ—®ğ—¹ğŸ°, ğ—¼ğ—¸ğŸ­ := <-ğ˜ƒğ—®ğ—¹ğŸ®:
        ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := ret1Err[*B]()
        if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
            return ğ—²ğ—¿ğ—¿ğŸ¯
        }
        *ğ˜ƒğ—®ğ—¹ğŸ¯ = ğ˜ƒğ—®ğ—¹ğŸ°
        ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ° := ret1Err[*bool]()
        if ğ—²ğ—¿ğ—¿ğŸ° != nil {
            return ğ—²ğ—¿ğ—¿ğŸ°
        }
        *ğ˜ƒğ—®ğ—¹ğŸ± = ğ—¼ğ—¸ğŸ­
    case ğ˜ƒğ—®ğ—¹ğŸ² <- ğ˜ƒğ—®ğ—¹ğŸ³:
    case ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ := <-ğ˜ƒğ—®ğ—¹ğŸ´:
        ğ˜ƒğ—®ğ—¹ğŸµ, ğ—²ğ—¿ğ—¿ğŸ´ := ret1Err[[]F]()
        if ğ—²ğ—¿ğ—¿ğŸ´ != nil {
            return ğ—²ğ—¿ğ—¿ğŸ´
        }
        ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬, ğ—²ğ—¿ğ—¿ğŸµ := ret1Err[G]()
        if ğ—²ğ—¿ğ—¿ğŸµ != nil {
            return ğ—²ğ—¿ğ—¿ğŸµ
        }
        ğ˜ƒğ—®ğ—¹ğŸµ[ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬] = ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­
    default:
}
```

</td>
</tr>

</table>

### Goto Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
L:
    var a = Try(ret1Err[int]())
    goto L
    println(a)
```

</td>
<td>

```golang
L:
    ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[int]()
    if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
        return ğ—²ğ—¿ğ—¿ğŸ­
    }
    var a = ğ˜ƒğ—®ğ—¹ğŸ­
    goto L
    println(a)
```

</td>
</tr>

</table>

### Assign Stmt

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
*id(&i) = Try(ret1Err[int]())
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­ := id(&i)
ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[int]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return
}
*ğ˜ƒğ—®ğ—¹ğŸ­ = ğ˜ƒğ—®ğ—¹ğŸ®
```

</td>
</tr>

</table>

### Map Index Expr

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
// panic when writting nil map
{
	var m map[int]int
	m[Try(ret1Err[int]())] = 1
}

// won't panic when reading nil map
{
	var m map[int]int
	println(m[0], Try(ret1Err[int]()))
}

// panic when reading map[any]T
{
	var m map[any]int
	println(m[0], Try(ret1Err[int]()))
}
```

</td>
<td>

```golang
{
	var m map[int]int
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[int]()
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	m[ğ˜ƒğ—®ğ—¹ğŸ­] = 1
}
{
	var m map[int]int
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[int]()
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	println(m[0], ğ˜ƒğ—®ğ—¹ğŸ®)
}
{
	var m map[any]int
	ğ˜ƒğ—®ğ—¹ğŸ¯ := m[0]
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := ret1Err[int]()
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ¯
	}
	println(ğ˜ƒğ—®ğ—¹ğŸ¯, ğ˜ƒğ—®ğ—¹ğŸ°)
}
```

</td>
</tr>

</table>

### Type Assert

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
expr, ok := Try(ret1Err[ast.Node]()).(ast.Expr)
_, _ = expr, ok
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[ast.Node]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
    return ğ—²ğ—¿ğ—¿ğŸ­
}
expr, ok := ğ˜ƒğ—®ğ—¹ğŸ­.(ast.Expr)
_, _ = expr, ok
```

</td>
</tr>

</table>

### Tuple Assign

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
_, _ = map[int]int{}[Try(ret1Err[int]())]
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[int]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
    return ğ—²ğ—¿ğ—¿ğŸ­
}
_, _ = map[int]int{}[ğ˜ƒğ—®ğ—¹ğŸ­]
```

</td>
</tr>

</table>

### Selector Expr

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
func rewrite_ptr_selector_expr() error {
	var x *ast.CallExpr
	{
		// MAY PANIC
		consume2(x.Args, Try(ret1Err[string]()))
	}
	{
		// MUST NOT PANIC
		consume2(x.Pos, Try(ret1Err[string]()))
	}
	{
		// MAY PANIC
		consume2(x.Pos(), Try(ret1Err[string]()))
	}
	return nil
}

func rewrite_iface_selector_expr() error {
	var x ast.Node
	{
        // MAY PANIC
        consume2(x.Pos, Try(ret1Err[string]()))
	}
	{
        // MAY PANIC
        consume2(x.Pos(), Try(ret1Err[string]()))
	}
	return nil
}

```

</td>
<td>

```golang
func rewrite_ptr_selector_expr() error {
	var x *ast.CallExpr
	{
		ğ˜ƒğ—®ğ—¹ğŸ­ := x.Args
		ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[string]()
		if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ­
		}
		consume2(ğ˜ƒğ—®ğ—¹ğŸ­, ğ˜ƒğ—®ğ—¹ğŸ®)
	}
	{
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[string]()
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			return ğ—²ğ—¿ğ—¿ğŸ®
		}
		consume2(x.Pos, ğ˜ƒğ—®ğ—¹ğŸ¯)
	}
	{
		ğ˜ƒğ—®ğ—¹ğŸ° := x.Pos()
		ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ¯ := ret1Err[string]()
		if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ¯
		}
		consume2(ğ˜ƒğ—®ğ—¹ğŸ°, ğ˜ƒğ—®ğ—¹ğŸ±)
	}
	return nil
}
func rewrite_iface_selector_expr() error {
	var x ast.Node
	{
		ğ˜ƒğ—®ğ—¹ğŸ­ := x.Pos
		ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[string]()
		if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ­
		}
		consume2(ğ˜ƒğ—®ğ—¹ğŸ­, ğ˜ƒğ—®ğ—¹ğŸ®)
	}
	{
		ğ˜ƒğ—®ğ—¹ğŸ¯ := x.Pos()
		ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[string]()
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			return ğ—²ğ—¿ğ—¿ğŸ®
		}
		consume2(ğ˜ƒğ—®ğ—¹ğŸ¯, ğ˜ƒğ—®ğ—¹ğŸ°)
	}
	return nil
}
```

</td>
</tr>

</table>

### Runtime Panic

<table>

<tr>
<td> 

**Before**

</td> 
<td>

**After**

</td>
</tr>

<tr>
<td>

```golang
type X struct{ x int }
{
	var x X
	_ = x.x + Try(ret1Err[int]())
}
{
	var x *X
	_ = x.x + Try(ret1Err[int]())
}
```

</td>
<td>

```golang
type X struct{ x int }
{
	var x X
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[int]()
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return
	}
	_ = x.x + ğ˜ƒğ—®ğ—¹ğŸ­
}
{
	var x *X
	ğ˜ƒğ—®ğ—¹ğŸ® := x.x
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[int]()
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return
	}
	_ = ğ˜ƒğ—®ğ—¹ğŸ® + ğ˜ƒğ—®ğ—¹ğŸ¯
}
```

</td>
</tr>


<tr>
<td>

[runtime_panic_try_test.go](rewriter/test/runtime_panic_try_test.go)

</td>
<td>

[runtime_panic_test.go](rewriter/test/runtime_panic_test.go)

</td>
</tr>

</table>
