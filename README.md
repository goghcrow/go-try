## ğ–ğ¡ğšğ­ ğ¢ğ¬ ğ•˜ğ• -ğ•¥ğ•£ğ•ª

A source to source translator for error-propagating in golang.

The implementation of [***Proposal: A built-in Go error check function, try***](https://github.com/golang/proposal/blob/master/design/32437-try-builtin.md).


## Quick Start

Create source files ending with `_try.go` / `_try_test.go`.

Build tag `//go:build try` required.

Then `go generate -tags try ./...` (or run by IDE whatever).

And it is a good idea to switch custom build tag to `try` when working in goland or vscode,
so IDE will be happy to index and check your code.

## Example

Create file `copyfile_try.go`.

```golang
//go:build try

//go:generate go install github.com/goghcrow/go-try/cmd/trygen@main
//go:generate trygen
package example

import (
	"io"
	"os"

	. "github.com/goghcrow/go-try"
)

//goland:noinspection GoUnhandledErrorResult
func CopyFile(src, dst string) (err error) {
	r := Try(os.Open(src))
	defer r.Close()

	w := Try(os.Create(dst))
	defer func() {
		w.Close()
		if err != nil {
			os.Remove(dst) // only if a â€œtryâ€ fails
		}
	}()

	Try(io.Copy(w, r))
	Try0(w.Close())
	return nil
}
```

run go:generate and output `copyfile.go`.

```golang
//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
//go:generate go install github.com/goghcrow/go-try/cmd/trygen@main
//go:generate trygen
package example

import (
	. "github.com/goghcrow/go-try/rt"
	"io"
	"os"
)

//goland:noinspection GoUnhandledErrorResult
func CopyFile(src, dst string) (err error) {
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ® := os.Open(src)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	r := ğ˜ƒğ—®ğ—¹ğŸ­
	defer r.Close()
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ° := os.Create(dst)
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		return ğ—²ğ—¿ğ—¿ğŸ°
	}
	w := ğ˜ƒğ—®ğ—¹ğŸ¯
	defer func() {
		w.Close()
		if err != nil {
			os.Remove(dst)
		}
	}()
	_, ğ—²ğ—¿ğ—¿ğŸ± := io.Copy(w, r)
	if ğ—²ğ—¿ğ—¿ğŸ± != nil {
		return ğ—²ğ—¿ğ—¿ğŸ±
	}
	ğ—²ğ—¿ğ—¿ğŸ² := w.Close()
	if ğ—²ğ—¿ğ—¿ğŸ² != nil {
		return ğ—²ğ—¿ğ—¿ğŸ²
	}
	return nil
}
```

## Translating

```golang
package test

func func1[A, R any](a A) (_ R, _ error) { return }

func return1[A any]() (_ A)                          { return }
func ret0Err() (_ error)                             { return }
func ret1Err[A any]() (_ A, _ error)                 { return }
func ret2Err[A, B any]() (_ A, _ B, _ error)         { return }
func ret3Err[A, B, C any]() (_ A, _ B, _ C, _ error) { return }

func consume1[A any](A)             {}
func consume2[A, B any](A, B)       {}
func consume3[A, B, C any](A, B, C) {}

func id[A any](a A) A { return a }

func handleErrorf(err *error, format string, args ...interface{}) {
	if *err != nil {
		*err = fmt.Errorf(format+": %v", append(args, *err)...)
	}
}
```

<table>
<tr>
<td> 

</td>
<td> 

**Source**

</td> 
<td>

**Target**

</td>
</tr>



<tr>
<td> 

**Error Handling**

</td>
<td>

```golang
func error_wrapping() (a int, err error) {
	defer handleErrorf(&err, "something wrong")
	Try(ret1Err[bool]())
	a = 42
	return
}
```

</td>
<td>

```golang
func error_wrapping() (a int, err error) {
    defer handleErrorf(&err, "something wrong")
    _, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[bool]()
    if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
        err = ğ—²ğ—¿ğ—¿ğŸ­
        return
    }
    a = 42
    return
}
```

</td>
</tr>


<tr>
<td> 

**For Stmt**

</td>
<td>

```golang
for i := Try(ret1Err[A]()); 
    Try(func1[int, bool](i)); 
    Try(func1[A, C](i)) 
{
    println(i)
}
```

</td>
<td>

```golang
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[A]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ­
}
for i := ğ˜ƒğ—®ğ—¹ğŸ­; ; {
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := func1[int, bool](i)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	if !ğ˜ƒğ—®ğ—¹ğŸ® {
		break
	}
	println(i)
	_, ğ—²ğ—¿ğ—¿ğŸ¯ := func1[A, C](i)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ¯
	}
}
```

</td>
</tr>


<tr>
<td> 

**Select Stmt**

</td>
<td>

```golang
type (
	A = int
	B = int
	C = int
	D = int
	E = int
	F = int
	G = int
	H = int
)
select {
    case <-Try(ret1Err[chan A]()):
    case *Try(ret1Err[*B]()), *Try(ret1Err[*bool]()) = <-Try(ret1Err[chan C]()):
    case Try(ret1Err[chan D]()) <- Try(ret1Err[E]()):
    case Try(ret1Err[[]F]())[Try(ret1Err[G]())] = <-Try(ret1Err[chan H]()):
    default:
}
```

</td>
<td>

```golang
type (
	A = int
	B = int
	C = int
	D = int
	E = int
	F = int
	G = int
	H = int
)
ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := ret1Err[chan A]()
if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ­
}
ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := ret1Err[chan C]()
if ğ—²ğ—¿ğ—¿ğŸ® != nil {
	return ğ—²ğ—¿ğ—¿ğŸ®
}
ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ± := ret1Err[chan D]()
if ğ—²ğ—¿ğ—¿ğŸ± != nil {
	return ğ—²ğ—¿ğ—¿ğŸ±
}
ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ² := ret1Err[E]()
if ğ—²ğ—¿ğ—¿ğŸ² != nil {
	return ğ—²ğ—¿ğ—¿ğŸ²
}
ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ³ := ret1Err[chan H]()
if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
	return ğ—²ğ—¿ğ—¿ğŸ³
}
select {
    case <-ğ˜ƒğ—®ğ—¹ğŸ­:
    case ğ˜ƒğ—®ğ—¹ğŸ°, ğ—¼ğ—¸ğŸ­ := <-ğ˜ƒğ—®ğ—¹ğŸ®:
        ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := ret1Err[*B]()
        if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
            return ğ—²ğ—¿ğ—¿ğŸ¯
        }
        *ğ˜ƒğ—®ğ—¹ğŸ¯ = ğ˜ƒğ—®ğ—¹ğŸ°
        ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ° := ret1Err[*bool]()
        if ğ—²ğ—¿ğ—¿ğŸ° != nil {
            return ğ—²ğ—¿ğ—¿ğŸ°
        }
        *ğ˜ƒğ—®ğ—¹ğŸ± = ğ—¼ğ—¸ğŸ­
    case ğ˜ƒğ—®ğ—¹ğŸ² <- ğ˜ƒğ—®ğ—¹ğŸ³:
    case ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ := <-ğ˜ƒğ—®ğ—¹ğŸ´:
        ğ˜ƒğ—®ğ—¹ğŸµ, ğ—²ğ—¿ğ—¿ğŸ´ := ret1Err[[]F]()
        if ğ—²ğ—¿ğ—¿ğŸ´ != nil {
            return ğ—²ğ—¿ğ—¿ğŸ´
        }
        ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬, ğ—²ğ—¿ğ—¿ğŸµ := ret1Err[G]()
        if ğ—²ğ—¿ğ—¿ğŸµ != nil {
            return ğ—²ğ—¿ğ—¿ğŸµ
        }
        ğ˜ƒğ—®ğ—¹ğŸµ[ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬] = ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­
    default:
}
```

</td>
</tr>

</table>