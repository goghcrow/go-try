//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

func assertequal(is, shouldbe int, msg string) {
	if is != shouldbe {
		print("assertion fail", msg, "\n")
		panic(1)
	}
}
func testForStmt() (err error) {
	var i, sum int
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := lit(0)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	i = ğ˜ƒğ—®ğ—¹ğŸ­
	for {
		i = i + 1
		ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := lit(5)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		if i > ğ˜ƒğ—®ğ—¹ğŸ® {
			break
		}
	}
	assertequal(i, 6, "break")
	sum = 0
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(0)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}
	for i := ğ˜ƒğ—®ğ—¹ğŸ¯; ; i++ {
		ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ° := lit(10)
		if ğ—²ğ—¿ğ—¿ğŸ° != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ°
			return
		}
		if i > ğ˜ƒğ—®ğ—¹ğŸ° {
			break
		}
		ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ± := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ± != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ±
			return
		}
		sum = sum + ğ˜ƒğ—®ğ—¹ğŸ±
	}
	assertequal(sum, 55, "all three")
	sum = 0
	for i := 0; ; {
		ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ² := lit(10)
		if ğ—²ğ—¿ğ—¿ğŸ² != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ²
			return
		}
		if i > ğ˜ƒğ—®ğ—¹ğŸ² {
			break
		}
		ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ³ := lit(sum + i)
		if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ³
			return
		}
		sum = ğ˜ƒğ—®ğ—¹ğŸ³
		i++
	}
	assertequal(sum, 55, "only two")
	sum = 0
	for sum < 100 {
		ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ´ := lit(9)
		if ğ—²ğ—¿ğ—¿ğŸ´ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ´
			return
		}
		sum = sum + ğ˜ƒğ—®ğ—¹ğŸ´
	}
	assertequal(sum, 99+9, "only one")
	sum = 0
	for i := 0; i <= 10; i++ {
		ğ˜ƒğ—®ğ—¹ğŸµ, ğ—²ğ—¿ğ—¿ğŸµ := lit(0)
		if ğ—²ğ—¿ğ—¿ğŸµ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸµ
			return
		}
		if i%2 == ğ˜ƒğ—®ğ—¹ğŸµ {
			continue
		}
		sum = sum + i
	}
	assertequal(sum, 1+3+5+7+9, "continue")
	i = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬, ğ—²ğ—¿ğ—¿ğŸ­ğŸ¬ := lit([5]struct{}{})
	if ğ—²ğ—¿ğ—¿ğŸ­ğŸ¬ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­ğŸ¬
		return
	}
	for i = range ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬ {
	}
	assertequal(i, 4, " incorrect index value after range loop")
	i = 0
	var a1 [5]struct{}
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ğŸ­ := lit(a1)
	if ğ—²ğ—¿ğ—¿ğŸ­ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­ğŸ­
		return
	}
	for i = range ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ {
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ğŸ® := lit(struct{}{})
		if ğ—²ğ—¿ğ—¿ğŸ­ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ­ğŸ®
			return
		}
		a1[i] = ğ˜ƒğ—®ğ—¹ğŸ­ğŸ®
	}
	assertequal(i, 4, " incorrect index value after array with zero size elem range clear")
	i = 0
	var a2 [5]int
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ­ğŸ¯ := lit(a2)
	if ğ—²ğ—¿ğ—¿ğŸ­ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­ğŸ¯
		return
	}
	for i = range ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¯ {
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ°, ğ—²ğ—¿ğ—¿ğŸ­ğŸ° := lit(0)
		if ğ—²ğ—¿ğ—¿ğŸ­ğŸ° != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ­ğŸ°
			return
		}
		a2[i] = ğ˜ƒğ—®ğ—¹ğŸ­ğŸ°
	}
	assertequal(i, 4, " incorrect index value after array range clear")
	return
}
