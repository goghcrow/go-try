//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

func gen(c chan int, lo, hi int) error {
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := lit(lo)
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	for i := 𝘃𝗮𝗹𝟭; ; i++ {
		𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := lit(hi)
		if 𝗲𝗿𝗿𝟮 != nil {
			return 𝗲𝗿𝗿𝟮
		}
		if i > 𝘃𝗮𝗹𝟮 {
			break
		}
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟯 := lit(i)
		if 𝗲𝗿𝗿𝟯 != nil {
			return 𝗲𝗿𝗿𝟯
		}
		c <- 𝘃𝗮𝗹𝟯
	}
	close(c)
	return nil
}
func seq(lo, hi int) chan int { ; c := make(chan int); go gen(c, lo, hi); return c }

const alphabet = "abcdefghijklmnopqrstuvwxyz"

func testblankvars() error {
	n := 0
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := lit(alphabet)
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	for range 𝘃𝗮𝗹𝟭 {
		n++
	}
	if n != 26 {
		println("for range: wrong count", n, "want 26")
		panic("fail")
	}
	n = 0
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := lit(alphabet)
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝗲𝗿𝗿𝟮
	}
	for _ = range 𝘃𝗮𝗹𝟮 {
		n++
	}
	if n != 26 {
		println("for _ = range: wrong count", n, "want 26")
		panic("fail")
	}
	n = 0
	𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟯 := lit(alphabet)
	if 𝗲𝗿𝗿𝟯 != nil {
		return 𝗲𝗿𝗿𝟯
	}
	for _, _ = range 𝘃𝗮𝗹𝟯 {
		n++
	}
	if n != 26 {
		println("for _, _ = range: wrong count", n, "want 26")
		panic("fail")
	}
	s := 0
	𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟰 := lit(alphabet)
	if 𝗲𝗿𝗿𝟰 != nil {
		return 𝗲𝗿𝗿𝟰
	}
	for i, _ := range 𝘃𝗮𝗹𝟰 {
		𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟱 := lit(i)
		if 𝗲𝗿𝗿𝟱 != nil {
			return 𝗲𝗿𝗿𝟱
		}
		s += 𝘃𝗮𝗹𝟱
	}
	𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟲 := lit(325)
	if 𝗲𝗿𝗿𝟲 != nil {
		return 𝗲𝗿𝗿𝟲
	}
	if s != 𝘃𝗮𝗹𝟲 {
		println("for i, _ := range: wrong sum", s, "want 325")
		panic("fail")
	}
	r := rune(0)
	𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟳 := lit(alphabet)
	if 𝗲𝗿𝗿𝟳 != nil {
		return 𝗲𝗿𝗿𝟳
	}
	for _, v := range 𝘃𝗮𝗹𝟳 {
		𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟴 := lit(v)
		if 𝗲𝗿𝗿𝟴 != nil {
			return 𝗲𝗿𝗿𝟴
		}
		r += 𝘃𝗮𝗹𝟴
	}
	𝘃𝗮𝗹𝟵, 𝗲𝗿𝗿𝟵 := lit[rune](2847)
	if 𝗲𝗿𝗿𝟵 != nil {
		return 𝗲𝗿𝗿𝟵
	}
	if r != 𝘃𝗮𝗹𝟵 {
		println("for _, v := range: wrong sum", r, "want 2847")
		panic("fail")
	}
	return nil
}
func testchan() error {
	s := ""
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := lit[int]('z')
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	𝘃𝗮𝗹𝟮 := seq('a', 𝘃𝗮𝗹𝟭)
	𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(𝘃𝗮𝗹𝟮)
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝗲𝗿𝗿𝟮
	}
	for i := range 𝘃𝗮𝗹𝟯 {
		𝘃𝗮𝗹𝟰 := rune(i)
		𝘃𝗮𝗹𝟱 := string(𝘃𝗮𝗹𝟰)
		𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟯 := lit(𝘃𝗮𝗹𝟱)
		if 𝗲𝗿𝗿𝟯 != nil {
			return 𝗲𝗿𝗿𝟯
		}
		s += 𝘃𝗮𝗹𝟲
	}
	if s != alphabet {
		println("Wanted lowercase alphabet; got", s)
		panic("fail")
	}
	n := 0
	𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟰 := lit[int]('z')
	if 𝗲𝗿𝗿𝟰 != nil {
		return 𝗲𝗿𝗿𝟰
	}
	𝘃𝗮𝗹𝟴 := seq('a', 𝘃𝗮𝗹𝟳)
	for range 𝘃𝗮𝗹𝟴 {
		n++
	}
	if n != 26 {
		println("testchan wrong count", n, "want 26")
		panic("fail")
	}
	return nil
}

var nmake = 0

func makeslice() []int { ; nmake++; return []int{1, 2, 3, 4, 5} }
func testslice() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makeslice()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for _, v := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(v)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := lit(1)
	if 𝗲𝗿𝗿𝟯 != nil {
		err = 𝗲𝗿𝗿𝟯
		return
	}
	if nmake != 𝘃𝗮𝗹𝟰 {
		println("range called makeslice", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over makeslice", s)
		panic("fail")
	}
	𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟰 := lit(20)
	if 𝗲𝗿𝗿𝟰 != nil {
		err = 𝗲𝗿𝗿𝟰
		return
	}
	x := []int{10, 𝘃𝗮𝗹𝟱}
	y := []int{99}
	i := 1
	𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟱 := lit(y)
	if 𝗲𝗿𝗿𝟱 != nil {
		err = 𝗲𝗿𝗿𝟱
		return
	}
	for i, x[i] = range 𝘃𝗮𝗹𝟲 {
		break
	}
	𝘃𝗮𝗹𝟳 := x[0]
	𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟲 := lit(𝘃𝗮𝗹𝟳 != 10)
	if 𝗲𝗿𝗿𝟲 != nil {
		err = 𝗲𝗿𝗿𝟲
		return
	}
	𝘃𝗮𝗹𝟭𝟭 := i != 0 || 𝘃𝗮𝗹𝟴
	if !𝘃𝗮𝗹𝟭𝟭 {
		𝘃𝗮𝗹𝟵 := x[1]
		𝘃𝗮𝗹𝟭𝟬, 𝗲𝗿𝗿𝟳 := lit(99)
		if 𝗲𝗿𝗿𝟳 != nil {
			err = 𝗲𝗿𝗿𝟳
			return
		}
		𝘃𝗮𝗹𝟭𝟭 = 𝘃𝗮𝗹𝟵 != 𝘃𝗮𝗹𝟭𝟬
	}
	if 𝘃𝗮𝗹𝟭𝟭 {
		println("wrong parallel assignment", i, x[0], x[1])
		panic("fail")
	}
	return
}
func testslice1() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makeslice()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for i := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(i)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makeslice", nmake, "times")
		panic("fail")
	}
	𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := lit(10)
	if 𝗲𝗿𝗿𝟯 != nil {
		err = 𝗲𝗿𝗿𝟯
		return
	}
	if s != 𝘃𝗮𝗹𝟰 {
		println("wrong sum ranging over makeslice", s)
		panic("fail")
	}
	return
}
func testslice2() (err error) {
	n := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makeslice()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for range 𝘃𝗮𝗹𝟮 {
		n++
	}
	if nmake != 1 {
		println("range called makeslice", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makeslice", n)
		panic("fail")
	}
	return
}
func makenumstring() string { ; nmake++; return "\x01\x02\x03\x04\x05" }
func testslice3() (err error) {
	s := byte(0)
	nmake = 0
	𝘃𝗮𝗹𝟭 := makenumstring()
	𝘃𝗮𝗹𝟮 := []byte(𝘃𝗮𝗹𝟭)
	𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟮)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for _, v := range 𝘃𝗮𝗹𝟯 {
		𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟮 := lit(v)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟰
	}
	if nmake != 1 {
		println("range called makenumstring", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over []byte(makenumstring)", s)
		panic("fail")
	}
	return
}
func makearray() [5]int { ; nmake++; return [5]int{1, 2, 3, 4, 5} }
func testarray() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makearray()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for _, v := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(v)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makearray", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over makearray", s)
		panic("fail")
	}
	return
}
func testarray1() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makearray()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for i := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(i)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makearray", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makearray", s)
		panic("fail")
	}
	return
}
func testarray2() (err error) {
	n := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makearray()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for range 𝘃𝗮𝗹𝟮 {
		n++
	}
	if nmake != 1 {
		println("range called makearray", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makearray", n)
		panic("fail")
	}
	return
}
func makearrayptr() *[5]int { ; nmake++; return &[5]int{1, 2, 3, 4, 5} }
func testarrayptr() (err error) {
	nmake = 0
	x := len(makearrayptr())
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := lit(x != 5)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	if !𝘃𝗮𝗹𝟭 {
		𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := lit(nmake != 1)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		𝘃𝗮𝗹𝟭 = 𝘃𝗮𝗹𝟮
	}
	if 𝘃𝗮𝗹𝟭 {
		println("len called makearrayptr", nmake, "times and got len", x)
		panic("fail")
	}
	nmake = 0
	x = cap(makearrayptr())
	𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟯 := lit(nmake != 1)
	if 𝗲𝗿𝗿𝟯 != nil {
		err = 𝗲𝗿𝗿𝟯
		return
	}
	if x != 5 || 𝘃𝗮𝗹𝟯 {
		println("cap called makearrayptr", nmake, "times and got len", x)
		panic("fail")
	}
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟰 := makearrayptr()
	𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟰 := lit(𝘃𝗮𝗹𝟰)
	if 𝗲𝗿𝗿𝟰 != nil {
		err = 𝗲𝗿𝗿𝟰
		return
	}
	for _, v := range 𝘃𝗮𝗹𝟱 {
		𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟱 := lit(v)
		if 𝗲𝗿𝗿𝟱 != nil {
			err = 𝗲𝗿𝗿𝟱
			return
		}
		s += 𝘃𝗮𝗹𝟲
	}
	if nmake != 1 {
		println("range called makearrayptr", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over makearrayptr", s)
		panic("fail")
	}
	return
}
func testarrayptr1() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makearrayptr()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for i := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(i)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makearrayptr", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makearrayptr", s)
		panic("fail")
	}
	return
}
func testarrayptr2() (err error) {
	n := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makearrayptr()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for range 𝘃𝗮𝗹𝟮 {
		n++
	}
	if nmake != 1 {
		println("range called makearrayptr", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makearrayptr", n)
		panic("fail")
	}
	return
}
func makestring() string { ; nmake++; return "abcd☺" }
func teststring() (err error) {
	var s rune
	nmake = 0
	𝘃𝗮𝗹𝟭 := makestring()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for _, v := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(v)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makestring", nmake, "times")
		panic("fail")
	}
	𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := lit('c')
	if 𝗲𝗿𝗿𝟯 != nil {
		err = 𝗲𝗿𝗿𝟯
		return
	}
	if s != 'a'+'b'+𝘃𝗮𝗹𝟰+'d'+'☺' {
		println("wrong sum ranging over makestring", s)
		panic("fail")
	}
	𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟰 := lit('b')
	if 𝗲𝗿𝗿𝟰 != nil {
		err = 𝗲𝗿𝗿𝟰
		return
	}
	x := []rune{'a', 𝘃𝗮𝗹𝟱}
	i := 1
	𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟱 := lit("c")
	if 𝗲𝗿𝗿𝟱 != nil {
		err = 𝗲𝗿𝗿𝟱
		return
	}
	for i, x[i] = range 𝘃𝗮𝗹𝟲 {
		break
	}
	𝘃𝗮𝗹𝟳 := x[0]
	𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟲 := lit(𝘃𝗮𝗹𝟳 != 'a')
	if 𝗲𝗿𝗿𝟲 != nil {
		err = 𝗲𝗿𝗿𝟲
		return
	}
	𝘃𝗮𝗹𝟭𝟭 := i != 0 || 𝘃𝗮𝗹𝟴
	if !𝘃𝗮𝗹𝟭𝟭 {
		𝘃𝗮𝗹𝟵 := x[1]
		𝘃𝗮𝗹𝟭𝟬, 𝗲𝗿𝗿𝟳 := lit('c')
		if 𝗲𝗿𝗿𝟳 != nil {
			err = 𝗲𝗿𝗿𝟳
			return
		}
		𝘃𝗮𝗹𝟭𝟭 = 𝘃𝗮𝗹𝟵 != 𝘃𝗮𝗹𝟭𝟬
	}
	if 𝘃𝗮𝗹𝟭𝟭 {
		println("wrong parallel assignment", i, x[0], x[1])
		panic("fail")
	}
	y := []int{1, 2, 3}
	r := rune(1)
	𝘃𝗮𝗹𝟭𝟮, 𝗲𝗿𝗿𝟴 := lit("\x02")
	if 𝗲𝗿𝗿𝟴 != nil {
		err = 𝗲𝗿𝗿𝟴
		return
	}
	for y[r], r = range 𝘃𝗮𝗹𝟭𝟮 {
		break
	}
	𝘃𝗮𝗹𝟭𝟯 := y[0]
	𝘃𝗮𝗹𝟭𝟱 := r != 2 || 𝘃𝗮𝗹𝟭𝟯 != 1
	if !𝘃𝗮𝗹𝟭𝟱 {
		𝘃𝗮𝗹𝟭𝟰 := y[1]
		𝘃𝗮𝗹𝟭𝟱 = 𝘃𝗮𝗹𝟭𝟰 != 0
	}
	if !𝘃𝗮𝗹𝟭𝟱 {
		𝘃𝗮𝗹𝟭𝟲, 𝗲𝗿𝗿𝟵 := lit(2)
		if 𝗲𝗿𝗿𝟵 != nil {
			err = 𝗲𝗿𝗿𝟵
			return
		}
		𝘃𝗮𝗹𝟭𝟳 := y[𝘃𝗮𝗹𝟭𝟲]
		𝘃𝗮𝗹𝟭𝟴, 𝗲𝗿𝗿𝟭𝟬 := lit(𝘃𝗮𝗹𝟭𝟳 != 3)
		if 𝗲𝗿𝗿𝟭𝟬 != nil {
			err = 𝗲𝗿𝗿𝟭𝟬
			return
		}
		𝘃𝗮𝗹𝟭𝟱 = 𝘃𝗮𝗹𝟭𝟴
	}
	if 𝘃𝗮𝗹𝟭𝟱 {
		println("wrong parallel assignment", r, y[0], y[1], y[2])
		panic("fail")
	}
	return
}
func teststring1() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makestring()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for i := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(i)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makestring", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makestring", s)
		panic("fail")
	}
	return
}
func teststring2() (err error) {
	n := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makestring()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for range 𝘃𝗮𝗹𝟮 {
		n++
	}
	if nmake != 1 {
		println("range called makestring", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makestring", n)
		panic("fail")
	}
	return
}
func makemap() map[int]int { ; nmake++; return map[int]int{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: '☺'} }
func testmap() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makemap()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for _, v := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := lit(v)
		if 𝗲𝗿𝗿𝟮 != nil {
			err = 𝗲𝗿𝗿𝟮
			return
		}
		s += 𝘃𝗮𝗹𝟯
	}
	if nmake != 1 {
		println("range called makemap", nmake, "times")
		panic("fail")
	}
	𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := lit[int]('☺')
	if 𝗲𝗿𝗿𝟯 != nil {
		err = 𝗲𝗿𝗿𝟯
		return
	}
	if s != 'a'+'b'+'c'+'d'+𝘃𝗮𝗹𝟰 {
		println("wrong sum ranging over makemap", s)
		panic("fail")
	}
	return
}
func testmap1() (err error) {
	s := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makemap()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for i := range 𝘃𝗮𝗹𝟮 {
		s += i
	}
	if nmake != 1 {
		println("range called makemap", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makemap", s)
		panic("fail")
	}
	return
}
func testmap2() (err error) {
	n := 0
	nmake = 0
	𝘃𝗮𝗹𝟭 := makemap()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := lit(𝘃𝗮𝗹𝟭)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	for range 𝘃𝗮𝗹𝟮 {
		n++
	}
	if nmake != 1 {
		println("range called makemap", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makemap", n)
		panic("fail")
	}
	return
}

var ncalls = 0

func getvar(p *int) *int { ; ncalls++; return p }
func testcalls() (err error) {
	var i, v int
	si := 0
	sv := 0
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := lit(2)
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := lit([2]int{1, 𝘃𝗮𝗹𝟭})
	if 𝗲𝗿𝗿𝟮 != nil {
		err = 𝗲𝗿𝗿𝟮
		return
	}
	for 𝗸𝟭, 𝘃𝟭 := range 𝘃𝗮𝗹𝟮 {
		𝘃𝗮𝗹𝟯 := getvar(&i)
		*𝘃𝗮𝗹𝟯 = 𝗸𝟭
		𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := lit(&v)
		if 𝗲𝗿𝗿𝟯 != nil {
			err = 𝗲𝗿𝗿𝟯
			return
		}
		𝘃𝗮𝗹𝟱 := getvar(𝘃𝗮𝗹𝟰)
		*𝘃𝗮𝗹𝟱 = 𝘃𝟭
		𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟰 := lit(i)
		if 𝗲𝗿𝗿𝟰 != nil {
			err = 𝗲𝗿𝗿𝟰
			return
		}
		si += 𝘃𝗮𝗹𝟲
		𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟱 := lit(v)
		if 𝗲𝗿𝗿𝟱 != nil {
			err = 𝗲𝗿𝗿𝟱
			return
		}
		sv += 𝘃𝗮𝗹𝟳
	}
	if ncalls != 4 {
		println("wrong number of calls:", ncalls, "!= 4")
		panic("fail")
	}
	if si != 1 || sv != 3 {
		println("wrong sum in testcalls", si, sv)
		panic("fail")
	}
	ncalls = 0
	𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟲 := lit([0]int{})
	if 𝗲𝗿𝗿𝟲 != nil {
		err = 𝗲𝗿𝗿𝟲
		return
	}
	for 𝗸𝟮, 𝘃𝟮 := range 𝘃𝗮𝗹𝟴 {
		𝘃𝗮𝗹𝟵, 𝗲𝗿𝗿𝟳 := lit(&i)
		if 𝗲𝗿𝗿𝟳 != nil {
			err = 𝗲𝗿𝗿𝟳
			return
		}
		𝘃𝗮𝗹𝟭𝟬 := getvar(𝘃𝗮𝗹𝟵)
		*𝘃𝗮𝗹𝟭𝟬 = 𝗸𝟮
		*getvar(&v) = 𝘃𝟮
		println("loop ran on empty array")
		panic("fail")
	}
	if ncalls != 0 {
		println("wrong number of calls:", ncalls, "!= 0")
		panic("fail")
	}
	return
}
func testRangeStmt() {
	_ = testblankvars()
	_ = testchan()
	_ = testarray()
	_ = testarray1()
	_ = testarray2()
	_ = testarrayptr()
	_ = testarrayptr1()
	_ = testarrayptr2()
	_ = testslice()
	_ = testslice1()
	_ = testslice2()
	_ = testslice3()
	_ = teststring()
	_ = teststring1()
	_ = teststring2()
	_ = testmap()
	_ = testmap1()
	_ = testmap2()
	_ = testcalls()
}
