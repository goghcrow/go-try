//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

func gen(c chan int, lo, hi int) error {
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := lit(lo)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	for i := ğ˜ƒğ—®ğ—¹ğŸ­; ; i++ {
		ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := lit(hi)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			return ğ—²ğ—¿ğ—¿ğŸ®
		}
		if i > ğ˜ƒğ—®ğ—¹ğŸ® {
			break
		}
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ¯
		}
		c <- ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	close(c)
	return nil
}
func seq(lo, hi int) chan int { ; c := make(chan int); go gen(c, lo, hi); return c }

const alphabet = "abcdefghijklmnopqrstuvwxyz"

func testblankvars() error {
	n := 0
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := lit(alphabet)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	for range ğ˜ƒğ—®ğ—¹ğŸ­ {
		n++
	}
	if n != 26 {
		println("for range: wrong count", n, "want 26")
		panic("fail")
	}
	n = 0
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := lit(alphabet)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	for _ = range ğ˜ƒğ—®ğ—¹ğŸ® {
		n++
	}
	if n != 26 {
		println("for _ = range: wrong count", n, "want 26")
		panic("fail")
	}
	n = 0
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(alphabet)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ¯
	}
	for _, _ = range ğ˜ƒğ—®ğ—¹ğŸ¯ {
		n++
	}
	if n != 26 {
		println("for _, _ = range: wrong count", n, "want 26")
		panic("fail")
	}
	s := 0
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ° := lit(alphabet)
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		return ğ—²ğ—¿ğ—¿ğŸ°
	}
	for i, _ := range ğ˜ƒğ—®ğ—¹ğŸ° {
		ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ± := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ± != nil {
			return ğ—²ğ—¿ğ—¿ğŸ±
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ±
	}
	ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ² := lit(325)
	if ğ—²ğ—¿ğ—¿ğŸ² != nil {
		return ğ—²ğ—¿ğ—¿ğŸ²
	}
	if s != ğ˜ƒğ—®ğ—¹ğŸ² {
		println("for i, _ := range: wrong sum", s, "want 325")
		panic("fail")
	}
	r := rune(0)
	ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ³ := lit(alphabet)
	if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ³
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ³ {
		ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ´ := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ´ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ´
		}
		r += ğ˜ƒğ—®ğ—¹ğŸ´
	}
	ğ˜ƒğ—®ğ—¹ğŸµ, ğ—²ğ—¿ğ—¿ğŸµ := lit[rune](2847)
	if ğ—²ğ—¿ğ—¿ğŸµ != nil {
		return ğ—²ğ—¿ğ—¿ğŸµ
	}
	if r != ğ˜ƒğ—®ğ—¹ğŸµ {
		println("for _, v := range: wrong sum", r, "want 2847")
		panic("fail")
	}
	return nil
}
func testchan() error {
	s := ""
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := lit[int]('z')
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		return ğ—²ğ—¿ğ—¿ğŸ­
	}
	ğ˜ƒğ—®ğ—¹ğŸ® := seq('a', ğ˜ƒğ—®ğ—¹ğŸ­)
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(ğ˜ƒğ—®ğ—¹ğŸ®)
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		return ğ—²ğ—¿ğ—¿ğŸ®
	}
	for i := range ğ˜ƒğ—®ğ—¹ğŸ¯ {
		ğ˜ƒğ—®ğ—¹ğŸ° := rune(i)
		ğ˜ƒğ—®ğ—¹ğŸ± := string(ğ˜ƒğ—®ğ—¹ğŸ°)
		ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ¯ := lit(ğ˜ƒğ—®ğ—¹ğŸ±)
		if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
			return ğ—²ğ—¿ğ—¿ğŸ¯
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ²
	}
	if s != alphabet {
		println("Wanted lowercase alphabet; got", s)
		panic("fail")
	}
	n := 0
	ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ° := lit[int]('z')
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		return ğ—²ğ—¿ğ—¿ğŸ°
	}
	ğ˜ƒğ—®ğ—¹ğŸ´ := seq('a', ğ˜ƒğ—®ğ—¹ğŸ³)
	for range ğ˜ƒğ—®ğ—¹ğŸ´ {
		n++
	}
	if n != 26 {
		println("testchan wrong count", n, "want 26")
		panic("fail")
	}
	return nil
}

var nmake = 0

func makeslice() []int { ; nmake++; return []int{1, 2, 3, 4, 5} }
func testslice() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makeslice()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(1)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}
	if nmake != ğ˜ƒğ—®ğ—¹ğŸ° {
		println("range called makeslice", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over makeslice", s)
		panic("fail")
	}
	ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ° := lit(20)
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ°
		return
	}
	x := []int{10, ğ˜ƒğ—®ğ—¹ğŸ±}
	y := []int{99}
	i := 1
	ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ± := lit(y)
	if ğ—²ğ—¿ğ—¿ğŸ± != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ±
		return
	}
	for i, x[i] = range ğ˜ƒğ—®ğ—¹ğŸ² {
		break
	}
	ğ˜ƒğ—®ğ—¹ğŸ³ := x[0]
	ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ² := lit(ğ˜ƒğ—®ğ—¹ğŸ³ != 10)
	if ğ—²ğ—¿ğ—¿ğŸ² != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ²
		return
	}
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ := i != 0 || ğ˜ƒğ—®ğ—¹ğŸ´
	if !ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ {
		ğ˜ƒğ—®ğ—¹ğŸµ := x[1]
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬, ğ—²ğ—¿ğ—¿ğŸ³ := lit(99)
		if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ³
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ = ğ˜ƒğ—®ğ—¹ğŸµ != ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬
	}
	if ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ {
		println("wrong parallel assignment", i, x[0], x[1])
		panic("fail")
	}
	return
}
func testslice1() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makeslice()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for i := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makeslice", nmake, "times")
		panic("fail")
	}
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(10)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}
	if s != ğ˜ƒğ—®ğ—¹ğŸ° {
		println("wrong sum ranging over makeslice", s)
		panic("fail")
	}
	return
}
func testslice2() (err error) {
	n := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makeslice()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for range ğ˜ƒğ—®ğ—¹ğŸ® {
		n++
	}
	if nmake != 1 {
		println("range called makeslice", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makeslice", n)
		panic("fail")
	}
	return
}
func makenumstring() string { ; nmake++; return "\x01\x02\x03\x04\x05" }
func testslice3() (err error) {
	s := byte(0)
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makenumstring()
	ğ˜ƒğ—®ğ—¹ğŸ® := []byte(ğ˜ƒğ—®ğ—¹ğŸ­)
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ®)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ¯ {
		ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ® := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ°
	}
	if nmake != 1 {
		println("range called makenumstring", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over []byte(makenumstring)", s)
		panic("fail")
	}
	return
}
func makearray() [5]int { ; nmake++; return [5]int{1, 2, 3, 4, 5} }
func testarray() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makearray()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makearray", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over makearray", s)
		panic("fail")
	}
	return
}
func testarray1() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makearray()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for i := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makearray", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makearray", s)
		panic("fail")
	}
	return
}
func testarray2() (err error) {
	n := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makearray()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for range ğ˜ƒğ—®ğ—¹ğŸ® {
		n++
	}
	if nmake != 1 {
		println("range called makearray", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makearray", n)
		panic("fail")
	}
	return
}
func makearrayptr() *[5]int { ; nmake++; return &[5]int{1, 2, 3, 4, 5} }
func testarrayptr() (err error) {
	nmake = 0
	x := len(makearrayptr())
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := lit(x != 5)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	if !ğ˜ƒğ—®ğ—¹ğŸ­ {
		ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := lit(nmake != 1)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ­ = ğ˜ƒğ—®ğ—¹ğŸ®
	}
	if ğ˜ƒğ—®ğ—¹ğŸ­ {
		println("len called makearrayptr", nmake, "times and got len", x)
		panic("fail")
	}
	nmake = 0
	x = cap(makearrayptr())
	ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(nmake != 1)
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}
	if x != 5 || ğ˜ƒğ—®ğ—¹ğŸ¯ {
		println("cap called makearrayptr", nmake, "times and got len", x)
		panic("fail")
	}
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ° := makearrayptr()
	ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ° := lit(ğ˜ƒğ—®ğ—¹ğŸ°)
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ°
		return
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ± {
		ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ± := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ± != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ±
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ²
	}
	if nmake != 1 {
		println("range called makearrayptr", nmake, "times")
		panic("fail")
	}
	if s != 15 {
		println("wrong sum ranging over makearrayptr", s)
		panic("fail")
	}
	return
}
func testarrayptr1() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makearrayptr()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for i := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makearrayptr", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makearrayptr", s)
		panic("fail")
	}
	return
}
func testarrayptr2() (err error) {
	n := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makearrayptr()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for range ğ˜ƒğ—®ğ—¹ğŸ® {
		n++
	}
	if nmake != 1 {
		println("range called makearrayptr", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makearrayptr", n)
		panic("fail")
	}
	return
}
func makestring() string { ; nmake++; return "abcdâ˜º" }
func teststring() (err error) {
	var s rune
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makestring()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makestring", nmake, "times")
		panic("fail")
	}
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := lit('c')
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}
	if s != 'a'+'b'+ğ˜ƒğ—®ğ—¹ğŸ°+'d'+'â˜º' {
		println("wrong sum ranging over makestring", s)
		panic("fail")
	}
	ğ˜ƒğ—®ğ—¹ğŸ±, ğ—²ğ—¿ğ—¿ğŸ° := lit('b')
	if ğ—²ğ—¿ğ—¿ğŸ° != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ°
		return
	}
	x := []rune{'a', ğ˜ƒğ—®ğ—¹ğŸ±}
	i := 1
	ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ± := lit("c")
	if ğ—²ğ—¿ğ—¿ğŸ± != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ±
		return
	}
	for i, x[i] = range ğ˜ƒğ—®ğ—¹ğŸ² {
		break
	}
	ğ˜ƒğ—®ğ—¹ğŸ³ := x[0]
	ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ² := lit(ğ˜ƒğ—®ğ—¹ğŸ³ != 'a')
	if ğ—²ğ—¿ğ—¿ğŸ² != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ²
		return
	}
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ := i != 0 || ğ˜ƒğ—®ğ—¹ğŸ´
	if !ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ {
		ğ˜ƒğ—®ğ—¹ğŸµ := x[1]
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬, ğ—²ğ—¿ğ—¿ğŸ³ := lit('c')
		if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ³
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ = ğ˜ƒğ—®ğ—¹ğŸµ != ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬
	}
	if ğ˜ƒğ—®ğ—¹ğŸ­ğŸ­ {
		println("wrong parallel assignment", i, x[0], x[1])
		panic("fail")
	}
	y := []int{1, 2, 3}
	r := rune(1)
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ®, ğ—²ğ—¿ğ—¿ğŸ´ := lit("\x02")
	if ğ—²ğ—¿ğ—¿ğŸ´ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ´
		return
	}
	for y[r], r = range ğ˜ƒğ—®ğ—¹ğŸ­ğŸ® {
		break
	}
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¯ := y[0]
	ğ˜ƒğ—®ğ—¹ğŸ­ğŸ± := r != 2 || ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¯ != 1
	if !ğ˜ƒğ—®ğ—¹ğŸ­ğŸ± {
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ° := y[1]
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ± = ğ˜ƒğ—®ğ—¹ğŸ­ğŸ° != 0
	}
	if !ğ˜ƒğ—®ğ—¹ğŸ­ğŸ± {
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ², ğ—²ğ—¿ğ—¿ğŸµ := lit(2)
		if ğ—²ğ—¿ğ—¿ğŸµ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸµ
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ³ := y[ğ˜ƒğ—®ğ—¹ğŸ­ğŸ²]
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ´, ğ—²ğ—¿ğ—¿ğŸ­ğŸ¬ := lit(ğ˜ƒğ—®ğ—¹ğŸ­ğŸ³ != 3)
		if ğ—²ğ—¿ğ—¿ğŸ­ğŸ¬ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ­ğŸ¬
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ± = ğ˜ƒğ—®ğ—¹ğŸ­ğŸ´
	}
	if ğ˜ƒğ—®ğ—¹ğŸ­ğŸ± {
		println("wrong parallel assignment", r, y[0], y[1], y[2])
		panic("fail")
	}
	return
}
func teststring1() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makestring()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for i := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makestring", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makestring", s)
		panic("fail")
	}
	return
}
func teststring2() (err error) {
	n := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makestring()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for range ğ˜ƒğ—®ğ—¹ğŸ® {
		n++
	}
	if nmake != 1 {
		println("range called makestring", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makestring", n)
		panic("fail")
	}
	return
}
func makemap() map[int]int { ; nmake++; return map[int]int{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'â˜º'} }
func testmap() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makemap()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for _, v := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯, ğ—²ğ—¿ğ—¿ğŸ® := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ® != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ®
			return
		}
		s += ğ˜ƒğ—®ğ—¹ğŸ¯
	}
	if nmake != 1 {
		println("range called makemap", nmake, "times")
		panic("fail")
	}
	ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := lit[int]('â˜º')
	if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ¯
		return
	}
	if s != 'a'+'b'+'c'+'d'+ğ˜ƒğ—®ğ—¹ğŸ° {
		println("wrong sum ranging over makemap", s)
		panic("fail")
	}
	return
}
func testmap1() (err error) {
	s := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makemap()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for i := range ğ˜ƒğ—®ğ—¹ğŸ® {
		s += i
	}
	if nmake != 1 {
		println("range called makemap", nmake, "times")
		panic("fail")
	}
	if s != 10 {
		println("wrong sum ranging over makemap", s)
		panic("fail")
	}
	return
}
func testmap2() (err error) {
	n := 0
	nmake = 0
	ğ˜ƒğ—®ğ—¹ğŸ­ := makemap()
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ­ := lit(ğ˜ƒğ—®ğ—¹ğŸ­)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	for range ğ˜ƒğ—®ğ—¹ğŸ® {
		n++
	}
	if nmake != 1 {
		println("range called makemap", nmake, "times")
		panic("fail")
	}
	if n != 5 {
		println("wrong count ranging over makemap", n)
		panic("fail")
	}
	return
}

var ncalls = 0

func getvar(p *int) *int { ; ncalls++; return p }
func testcalls() (err error) {
	var i, v int
	si := 0
	sv := 0
	ğ˜ƒğ—®ğ—¹ğŸ­, ğ—²ğ—¿ğ—¿ğŸ­ := lit(2)
	if ğ—²ğ—¿ğ—¿ğŸ­ != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ­
		return
	}
	ğ˜ƒğ—®ğ—¹ğŸ®, ğ—²ğ—¿ğ—¿ğŸ® := lit([2]int{1, ğ˜ƒğ—®ğ—¹ğŸ­})
	if ğ—²ğ—¿ğ—¿ğŸ® != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ®
		return
	}
	for ğ—¸ğŸ­, ğ˜ƒğŸ­ := range ğ˜ƒğ—®ğ—¹ğŸ® {
		ğ˜ƒğ—®ğ—¹ğŸ¯ := getvar(&i)
		*ğ˜ƒğ—®ğ—¹ğŸ¯ = ğ—¸ğŸ­
		ğ˜ƒğ—®ğ—¹ğŸ°, ğ—²ğ—¿ğ—¿ğŸ¯ := lit(&v)
		if ğ—²ğ—¿ğ—¿ğŸ¯ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ¯
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ± := getvar(ğ˜ƒğ—®ğ—¹ğŸ°)
		*ğ˜ƒğ—®ğ—¹ğŸ± = ğ˜ƒğŸ­
		ğ˜ƒğ—®ğ—¹ğŸ², ğ—²ğ—¿ğ—¿ğŸ° := lit(i)
		if ğ—²ğ—¿ğ—¿ğŸ° != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ°
			return
		}
		si += ğ˜ƒğ—®ğ—¹ğŸ²
		ğ˜ƒğ—®ğ—¹ğŸ³, ğ—²ğ—¿ğ—¿ğŸ± := lit(v)
		if ğ—²ğ—¿ğ—¿ğŸ± != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ±
			return
		}
		sv += ğ˜ƒğ—®ğ—¹ğŸ³
	}
	if ncalls != 4 {
		println("wrong number of calls:", ncalls, "!= 4")
		panic("fail")
	}
	if si != 1 || sv != 3 {
		println("wrong sum in testcalls", si, sv)
		panic("fail")
	}
	ncalls = 0
	ğ˜ƒğ—®ğ—¹ğŸ´, ğ—²ğ—¿ğ—¿ğŸ² := lit([0]int{})
	if ğ—²ğ—¿ğ—¿ğŸ² != nil {
		err = ğ—²ğ—¿ğ—¿ğŸ²
		return
	}
	for ğ—¸ğŸ®, ğ˜ƒğŸ® := range ğ˜ƒğ—®ğ—¹ğŸ´ {
		ğ˜ƒğ—®ğ—¹ğŸµ, ğ—²ğ—¿ğ—¿ğŸ³ := lit(&i)
		if ğ—²ğ—¿ğ—¿ğŸ³ != nil {
			err = ğ—²ğ—¿ğ—¿ğŸ³
			return
		}
		ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬ := getvar(ğ˜ƒğ—®ğ—¹ğŸµ)
		*ğ˜ƒğ—®ğ—¹ğŸ­ğŸ¬ = ğ—¸ğŸ®
		*getvar(&v) = ğ˜ƒğŸ®
		println("loop ran on empty array")
		panic("fail")
	}
	if ncalls != 0 {
		println("wrong number of calls:", ncalls, "!= 0")
		panic("fail")
	}
	return
}
func testRangeStmt() {
	_ = testblankvars()
	_ = testchan()
	_ = testarray()
	_ = testarray1()
	_ = testarray2()
	_ = testarrayptr()
	_ = testarrayptr1()
	_ = testarrayptr2()
	_ = testslice()
	_ = testslice1()
	_ = testslice2()
	_ = testslice3()
	_ = teststring()
	_ = teststring1()
	_ = teststring2()
	_ = testmap()
	_ = testmap1()
	_ = testmap2()
	_ = testcalls()
}
