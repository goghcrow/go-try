//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

func range_without_kv() error {
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[[]int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	for range 𝘃𝗮𝗹𝟭 {
	}
	return nil
}
func range_selector_assign() error {
	type X struct{ i int }
	type Y = X
	{
		for 𝗸𝟭, 𝘃𝟭 := range []int{} {
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[*X]()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭.i = 𝗸𝟭
			𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := ret1Err[*Y]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			𝘃𝗮𝗹𝟮.i = 𝘃𝟭
			println()
		}
	}
	{
		for 𝗸𝟮, 𝘃𝟮 := range []int{} {
			𝘃𝗮𝗹𝟯 := id[*X](nil)
			𝘃𝗮𝗹𝟯.i = 𝗸𝟮
			𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := ret1Err[*Y]()
			if 𝗲𝗿𝗿𝟯 != nil {
				return 𝗲𝗿𝗿𝟯
			}
			𝘃𝗮𝗹𝟰.i = 𝘃𝟮
			println()
		}
	}
	{
		for 𝗸𝟯, 𝘃𝟯 := range []int{} {
			𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟰 := ret1Err[*X]()
			if 𝗲𝗿𝗿𝟰 != nil {
				return 𝗲𝗿𝗿𝟰
			}
			𝘃𝗮𝗹𝟱.i = 𝗸𝟯
			id[*Y](nil).i = 𝘃𝟯
			println()
		}
	}
	{
		var i int
		for 𝗸𝟰, 𝘃𝟰 := range []int{} {
			i = 𝗸𝟰
			𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟱 := ret1Err[*X]()
			if 𝗲𝗿𝗿𝟱 != nil {
				return 𝗲𝗿𝗿𝟱
			}
			𝘃𝗮𝗹𝟲.i = 𝘃𝟰
			println(i)
		}
	}
	{
		var v int
		for 𝗸𝟱, 𝘃𝟱 := range []int{} {
			𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟲 := ret1Err[*X]()
			if 𝗲𝗿𝗿𝟲 != nil {
				return 𝗲𝗿𝗿𝟲
			}
			𝘃𝗮𝗹𝟳.i = 𝗸𝟱
			v = 𝘃𝟱
			println(v)
		}
	}
	{
		for 𝗸𝟲 := range []int{} {
			𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟳 := ret1Err[*X]()
			if 𝗲𝗿𝗿𝟳 != nil {
				return 𝗲𝗿𝗿𝟳
			}
			𝘃𝗮𝗹𝟴.i = 𝗸𝟲
		}
	}
	return nil
}
func range_index_assign() error {
	type X struct{ i int }
	{
		for 𝗸𝟭, 𝘃𝟭 := range []int{} {
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭[0] = 𝗸𝟭
			𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			𝘃𝗮𝗹𝟮[0] = 𝘃𝟭
			println()
		}
	}
	{
		for 𝗸𝟮, 𝘃𝟮 := range []int{} {
			[]int{}[0] = 𝗸𝟮
			𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟯 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟯 != nil {
				return 𝗲𝗿𝗿𝟯
			}
			𝘃𝗮𝗹𝟯[0] = 𝘃𝟮
			println()
		}
	}
	{
		for 𝗸𝟯, 𝘃𝟯 := range []int{} {
			𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟰 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟰 != nil {
				return 𝗲𝗿𝗿𝟰
			}
			𝘃𝗮𝗹𝟰[0] = 𝗸𝟯
			[]int{}[0] = 𝘃𝟯
			println()
		}
	}
	{
		var i int
		for 𝗸𝟰, 𝘃𝟰 := range []int{} {
			i = 𝗸𝟰
			𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟱 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟱 != nil {
				return 𝗲𝗿𝗿𝟱
			}
			𝘃𝗮𝗹𝟱[0] = 𝘃𝟰
			println(i)
		}
	}
	{
		var v int
		for 𝗸𝟱, 𝘃𝟱 := range []int{} {
			𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟲 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟲 != nil {
				return 𝗲𝗿𝗿𝟲
			}
			𝘃𝗮𝗹𝟲[0] = 𝗸𝟱
			v = 𝘃𝟱
			println(v)
		}
	}
	{
		for 𝗸𝟲 := range []int{} {
			𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟳 := ret1Err[[]int]()
			if 𝗲𝗿𝗿𝟳 != nil {
				return 𝗲𝗿𝗿𝟳
			}
			𝘃𝗮𝗹𝟳[0] = 𝗸𝟲
		}
	}
	return nil
}
func range_map_index_assign() error {
	{
		for 𝗸𝟭, 𝘃𝟭 := range []int{} {
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭[0] = 𝗸𝟭
			𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			𝘃𝗮𝗹𝟮[0] = 𝘃𝟭
			println()
		}
	}
	{
		for 𝗸𝟮, 𝘃𝟮 := range []int{} {
			map[int]int{}[0] = 𝗸𝟮
			𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟯 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟯 != nil {
				return 𝗲𝗿𝗿𝟯
			}
			𝘃𝗮𝗹𝟯[0] = 𝘃𝟮
			println()
		}
	}
	{
		for 𝗸𝟯, 𝘃𝟯 := range []int{} {
			𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟰 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟰 != nil {
				return 𝗲𝗿𝗿𝟰
			}
			𝘃𝗮𝗹𝟰[0] = 𝗸𝟯
			map[int]int{}[0] = 𝘃𝟯
			println()
		}
	}
	{
		var i int
		for 𝗸𝟰, 𝘃𝟰 := range []int{} {
			i = 𝗸𝟰
			𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟱 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟱 != nil {
				return 𝗲𝗿𝗿𝟱
			}
			𝘃𝗮𝗹𝟱[0] = 𝘃𝟰
			println(i)
		}
	}
	{
		var v int
		for 𝗸𝟱, 𝘃𝟱 := range []int{} {
			𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟲 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟲 != nil {
				return 𝗲𝗿𝗿𝟲
			}
			𝘃𝗮𝗹𝟲[0] = 𝗸𝟱
			v = 𝘃𝟱
			println(v)
		}
	}
	{
		for 𝗸𝟲 := range []int{} {
			𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟳 := ret1Err[map[int]int]()
			if 𝗲𝗿𝗿𝟳 != nil {
				return 𝗲𝗿𝗿𝟳
			}
			𝘃𝗮𝗹𝟳[0] = 𝗸𝟲
		}
	}
	return nil
}
