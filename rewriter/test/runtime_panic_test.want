//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

import "fmt"

func selecotr_val() (_ int, err error) {
	type X struct{ x int }
	var x X
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return x.x + 𝘃𝗮𝗹𝟭, nil
}
func panic_selecotr_ptr() (_ int, err error) {
	type X struct{ x int }
	var x *X
	𝘃𝗮𝗹𝟭 := x.x
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_selecotr_iface() (_ string, err error) {
	var s fmt.Stringer
	𝘃𝗮𝗹𝟭 := s.String()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[string]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_quo(zero int) (_ int, err error) {
	𝘃𝗮𝗹𝟭 := 42 / zero
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_shl(negative int) (_ int, err error) {
	𝘃𝗮𝗹𝟭 := 42 << negative
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panicRet[T any]() (z T) { ; panic("panic"); return z }
func panic_Panic() (_ int, err error) {
	𝘃𝗮𝗹𝟭 := panicRet[int]()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_call_nil_fun() (_ int, err error) {
	var f func() int
	𝘃𝗮𝗹𝟭 := f()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_call_nil_fun1() (_ int, err error) {
	type X struct{ f func() int }
	var x *X
	𝘃𝗮𝗹𝟭 := x.f()
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_type_conv(x any) (_ int, err error) {
	𝘃𝗮𝗹𝟭 := x.(int)
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	return 𝘃𝗮𝗹𝟭 + 𝘃𝗮𝗹𝟮, nil
}
func panic_type_conv1() (_ int, err error) {
	𝘃𝗮𝗹𝟭 := (*[1]int)([]int{})
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	consume2(𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮)
	return
}
func panic_type_conv2() (_ int, err error) {
	𝘃𝗮𝗹𝟭 := (*[1]int)([]int{})
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	consume2(𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮)
	return
}
func panic_make(negitive int) (_ int, err error) {
	𝘃𝗮𝗹𝟭 := make([]int, negitive)
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		err = 𝗲𝗿𝗿𝟭
		return
	}
	consume2(𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮)
	return
}
