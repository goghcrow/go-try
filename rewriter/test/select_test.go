//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

func select_eval_order0() {
	getRecvCh := func(s string, buf int) <-chan int {
		println("getRecvCh called: " + s)
		ch := make(chan int, buf)
		if buf > 0 {
			ch <- 42
		}
		return ch
	}
	mkValToSend := func() int { println("mkValToSend called"); return 0 }
	mkSndCh := func() chan<- int { println("mkSndCh called"); return make(chan int) }
	f := func() int { println("f called"); return 0 }
	getvar := func(p *int) *int { println("getvar called"); return p }
	var a = []int{1, 2, 3}
	var i1, i2 int
	select {
	case *getvar(&i1) = <-getRecvCh("c1", 1):
		print("received ", i1, " from c1\n")
	case mkSndCh() <- mkValToSend():
		print("sent ", i2, " to c2\n")
	case a[f()] = <-getRecvCh("c2", 0):
	default:
		print("no communication\n")
	}
}
func select_eval_order() error {
	type (
		A = int
		B = int
		C = int
		D = int
		E = int
		F = int
		G = int
		H = int
	)
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[chan A]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := ret1Err[chan C]()
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝗲𝗿𝗿𝟮
	}
	𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟱 := ret1Err[chan D]()
	if 𝗲𝗿𝗿𝟱 != nil {
		return 𝗲𝗿𝗿𝟱
	}
	𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟲 := ret1Err[E]()
	if 𝗲𝗿𝗿𝟲 != nil {
		return 𝗲𝗿𝗿𝟲
	}
	𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟳 := ret1Err[chan H]()
	if 𝗲𝗿𝗿𝟳 != nil {
		return 𝗲𝗿𝗿𝟳
	}
	select {
	case <-𝘃𝗮𝗹𝟭:
	case 𝘃𝗮𝗹𝟰, 𝗼𝗸𝟭 := <-𝘃𝗮𝗹𝟮:
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟯 := ret1Err[*B]()
		if 𝗲𝗿𝗿𝟯 != nil {
			return 𝗲𝗿𝗿𝟯
		}
		*𝘃𝗮𝗹𝟯 = 𝘃𝗮𝗹𝟰
		𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟰 := ret1Err[*bool]()
		if 𝗲𝗿𝗿𝟰 != nil {
			return 𝗲𝗿𝗿𝟰
		}
		*𝘃𝗮𝗹𝟱 = 𝗼𝗸𝟭
	case 𝘃𝗮𝗹𝟲 <- 𝘃𝗮𝗹𝟳:
	case 𝘃𝗮𝗹𝟭𝟭 := <-𝘃𝗮𝗹𝟴:
		𝘃𝗮𝗹𝟵, 𝗲𝗿𝗿𝟴 := ret1Err[[]F]()
		if 𝗲𝗿𝗿𝟴 != nil {
			return 𝗲𝗿𝗿𝟴
		}
		𝘃𝗮𝗹𝟭𝟬, 𝗲𝗿𝗿𝟵 := ret1Err[G]()
		if 𝗲𝗿𝗿𝟵 != nil {
			return 𝗲𝗿𝗿𝟵
		}
		𝘃𝗮𝗹𝟵[𝘃𝗮𝗹𝟭𝟬] = 𝘃𝗮𝗹𝟭𝟭
	default:
	}
	return nil
}
func select_eval_order1() error {
	type (
		A = int
		B = int
		C = int
	)
	var ch <-chan int
	select {
	case <-ch:
	case 𝘃𝗮𝗹𝟮, 𝗼𝗸𝟭 := <-ch:
		𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[*A]()
		if 𝗲𝗿𝗿𝟭 != nil {
			return 𝗲𝗿𝗿𝟭
		}
		*𝘃𝗮𝗹𝟭 = 𝘃𝗮𝗹𝟮
		_ = 𝗼𝗸𝟭
	case 𝘃𝗮𝗹𝟰 := <-ch:
		𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := ret1Err[*B]()
		if 𝗲𝗿𝗿𝟮 != nil {
			return 𝗲𝗿𝗿𝟮
		}
		*𝘃𝗮𝗹𝟯 = 𝘃𝗮𝗹𝟰
	case 𝘃𝗮𝗹𝟲, 𝗼𝗸𝟮 := <-ch:
		𝘃𝗮𝗹𝟱, 𝗲𝗿𝗿𝟯 := ret1Err[*C]()
		if 𝗲𝗿𝗿𝟯 != nil {
			return 𝗲𝗿𝗿𝟯
		}
		*𝘃𝗮𝗹𝟱 = 𝘃𝗮𝗹𝟲
		𝘃𝗮𝗹𝟳, 𝗲𝗿𝗿𝟰 := ret1Err[*bool]()
		if 𝗲𝗿𝗿𝟰 != nil {
			return 𝗲𝗿𝗿𝟰
		}
		*𝘃𝗮𝗹𝟳 = 𝗼𝗸𝟮
	case 𝘃𝗮𝗹𝟴, 𝗼𝗸𝟯 := <-ch:
		_ = 𝘃𝗮𝗹𝟴
		𝘃𝗮𝗹𝟵, 𝗲𝗿𝗿𝟱 := ret1Err[*bool]()
		if 𝗲𝗿𝗿𝟱 != nil {
			return 𝗲𝗿𝗿𝟱
		}
		*𝘃𝗮𝗹𝟵 = 𝗼𝗸𝟯
	default:
	}
	return nil
}
func rewrite_select() error {
	{
		𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[chan int]()
		if 𝗲𝗿𝗿𝟭 != nil {
			return 𝗲𝗿𝗿𝟭
		}
		select {
		case x, ok := (<-𝘃𝗮𝗹𝟭):
			_, _ = x, ok
		}
	}
	{
		select {
		case 𝘃𝗮𝗹𝟯 := <-(<-chan int)(nil):
			𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := ret1Err[*int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			*𝘃𝗮𝗹𝟮 = 𝘃𝗮𝗹𝟯
		default:
		}
	}
	return nil
}
