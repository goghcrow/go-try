//go:build !try

// Code generated by github.com/goghcrow/go-try DO NOT EDIT.
package test

import (
	"errors"
	. "github.com/goghcrow/go-try/rt"
)

type (
	Int int
	Str string
)

var helloErr = errors.New("hello error!")

func answer() (int, error) {
	var 𝘇𝗲𝗿𝗼𝟬 int
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟭
	}
	return 𝘃𝗮𝗹𝟭, nil
}
func assign() (_ error) {
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	x, y := 𝘃𝗮𝗹𝟭, 42
	consume2(x, y)
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := 42, helloErr
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝗲𝗿𝗿𝟮
	}
	v1, v2 := 𝘃𝗮𝗹𝟮, 42
	consume2(v1, v2)
	return nil
}
func binary() (_ error) {
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	consume1(𝘃𝗮𝗹𝟭 + 1)
	return nil
}
func ret0() (_ error) {
	𝗲𝗿𝗿𝟭 := ret0Err()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝗲𝗿𝗿𝟭
	}
	𝗲𝗿𝗿𝟮 := helloErr
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝗲𝗿𝗿𝟮
	}
	return
}
func ret1() (_ Int, _ error) {
	var 𝘇𝗲𝗿𝗼𝟬 Int
	_, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟭
	}
	𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟮 := ret1Err[int]()
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟮
	}
	consume1(𝘃𝗮𝗹𝟭 + 1)
	_, 𝗲𝗿𝗿𝟯 := 42, helloErr
	if 𝗲𝗿𝗿𝟯 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟯
	}
	𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟰 := 42, helloErr
	if 𝗲𝗿𝗿𝟰 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟰
	}
	consume1(𝘃𝗮𝗹𝟮 + 1)
	return
}
func ret2() (_ Int, _ Str, _ error) {
	var (
		𝘇𝗲𝗿𝗼𝟬 Int
		𝘇𝗲𝗿𝗼𝟭 Str
	)
	_, _, 𝗲𝗿𝗿𝟭 := ret2Err[int, string]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟭
	}
	𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮, 𝗲𝗿𝗿𝟮 := ret2Err[int, string]()
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟮
	}
	iV, bV := 𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮
	consume2(iV, bV)
	𝘃𝗮𝗹𝟯, 𝘃𝗮𝗹𝟰, 𝗲𝗿𝗿𝟯 := ret2Err[int, string]()
	if 𝗲𝗿𝗿𝟯 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟯
	}
	consume2(Ƭ2(𝘃𝗮𝗹𝟯, 𝘃𝗮𝗹𝟰))
	_, _, 𝗲𝗿𝗿𝟰 := 42, "answer", helloErr
	if 𝗲𝗿𝗿𝟰 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟰
	}
	𝘃𝗮𝗹𝟱, 𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟱 := 42, "answer", helloErr
	if 𝗲𝗿𝗿𝟱 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟱
	}
	iV, bV = 𝘃𝗮𝗹𝟱, 𝘃𝗮𝗹𝟲
	consume2(iV, bV)
	𝘃𝗮𝗹𝟳, 𝘃𝗮𝗹𝟴, 𝗲𝗿𝗿𝟲 := 42, "answer", helloErr
	if 𝗲𝗿𝗿𝟲 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟲
	}
	consume2(Ƭ2(𝘃𝗮𝗹𝟳, 𝘃𝗮𝗹𝟴))
	return
}
func ret2_grouped_ret() (_, _ Int, _ error) {
	var 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭 Int
	_, _, 𝗲𝗿𝗿𝟭 := ret2Err[int, byte]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝘇𝗲𝗿𝗼𝟭, 𝗲𝗿𝗿𝟭
	}
	return
}
func ret3() (_ *Int, _ error) {
	var 𝘇𝗲𝗿𝗼𝟬 *Int
	_, _, _, 𝗲𝗿𝗿𝟭 := ret3Err[int, rune, string]()
	if 𝗲𝗿𝗿𝟭 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟭
	}
	𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮, 𝘃𝗮𝗹𝟯, 𝗲𝗿𝗿𝟮 := ret3Err[int, rune, string]()
	if 𝗲𝗿𝗿𝟮 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟮
	}
	iV, bV, sV := 𝘃𝗮𝗹𝟭, 𝘃𝗮𝗹𝟮, 𝘃𝗮𝗹𝟯
	consume3(iV, bV, sV)
	𝘃𝗮𝗹𝟰, 𝘃𝗮𝗹𝟱, 𝘃𝗮𝗹𝟲, 𝗲𝗿𝗿𝟯 := ret3Err[int, rune, string]()
	if 𝗲𝗿𝗿𝟯 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟯
	}
	consume3(Ƭ3(𝘃𝗮𝗹𝟰, 𝘃𝗮𝗹𝟱, 𝘃𝗮𝗹𝟲))
	_, _, _, 𝗲𝗿𝗿𝟰 := 42, 'a', "hello", helloErr
	if 𝗲𝗿𝗿𝟰 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟰
	}
	𝘃𝗮𝗹𝟳, 𝘃𝗮𝗹𝟴, 𝘃𝗮𝗹𝟵, 𝗲𝗿𝗿𝟱 := 42, 'a', "hello", helloErr
	if 𝗲𝗿𝗿𝟱 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟱
	}
	iV, bV, sV = 𝘃𝗮𝗹𝟳, 𝘃𝗮𝗹𝟴, 𝘃𝗮𝗹𝟵
	consume3(iV, bV, sV)
	𝘃𝗮𝗹𝟭𝟬, 𝘃𝗮𝗹𝟭𝟭, 𝘃𝗮𝗹𝟭𝟮, 𝗲𝗿𝗿𝟲 := 42, 'a', "hello", helloErr
	if 𝗲𝗿𝗿𝟲 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟲
	}
	consume3(Ƭ3(𝘃𝗮𝗹𝟭𝟬, 𝘃𝗮𝗹𝟭𝟭, 𝘃𝗮𝗹𝟭𝟮))
	𝘃𝗮𝗹𝟭𝟯, 𝘃𝗮𝗹𝟭𝟰, 𝘃𝗮𝗹𝟭𝟱, 𝗲𝗿𝗿𝟳 := ret3Err[int, rune, string]()
	if 𝗲𝗿𝗿𝟳 != nil {
		return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟳
	}
	func(int, rune, string) {}(Ƭ3(𝘃𝗮𝗹𝟭𝟯, 𝘃𝗮𝗹𝟭𝟰, 𝘃𝗮𝗹𝟭𝟱))
	return
}
func funcLit() {
	go func() {
		𝘃𝗮𝗹𝟭 := func() error {
			𝗲𝗿𝗿𝟭 := ret0()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟮 := ret1Err[int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			consume1(𝘃𝗮𝗹𝟭)
			return nil
		}()
		_ = 𝘃𝗮𝗹𝟭
	}()
	defer func() {
		𝘃𝗮𝗹𝟭 := func() error {
			𝗲𝗿𝗿𝟭 := ret0()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟮 := ret1Err[int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			consume1(𝘃𝗮𝗹𝟭)
			return nil
		}()
		_ = 𝘃𝗮𝗹𝟭
	}()
	𝘃𝗮𝗹𝟭 := func() int {
		func() (int, error) {
			var 𝘇𝗲𝗿𝗼𝟬 int
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟭 := ret1Err[int]()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝘇𝗲𝗿𝗼𝟬, 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟮 := id(𝘃𝗮𝗹𝟭)
			return 𝘃𝗮𝗹𝟮, nil
		}()
		return 42
	}()
	if 𝘃𝗮𝗹𝟭 == 42 {
	}
}
func fnlit() {
	go func() {
		𝘃𝗮𝗹𝟭 := func() error {
			𝗲𝗿𝗿𝟭 := ret0()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟮 := ret1Err[int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			consume1(𝘃𝗮𝗹𝟭)
			return nil
		}()
		_ = 𝘃𝗮𝗹𝟭
	}()
	func() {
		𝘃𝗮𝗹𝟭 := func() error {
			𝗲𝗿𝗿𝟭 := ret0()
			if 𝗲𝗿𝗿𝟭 != nil {
				return 𝗲𝗿𝗿𝟭
			}
			𝘃𝗮𝗹𝟭, 𝗲𝗿𝗿𝟮 := ret1Err[int]()
			if 𝗲𝗿𝗿𝟮 != nil {
				return 𝗲𝗿𝗿𝟮
			}
			consume1(𝘃𝗮𝗹𝟭)
			return nil
		}()
		_ = 𝘃𝗮𝗹𝟭
	}()
}
